---
layout: post
title: 操作系统-PA1
---

时长：15h

## STFSC

---

## nemu/include/macro.h

---

- 宏&预处理运算符

  - https://en.cppreference.com/w/cpp/preprocessor
  - https://en.cppreference.com/w/cpp/preprocessor/replace#Predefined_macros(来自上面的链接)

```c
// macro stringizing
#define str_temp(x) #x
#define str(x) str_temp(x)
```

使用两个宏逐步展开，是为了防止 x 传入一个宏，如

```c
#define VALUE 42
#define str_temp(x) #x      // 第一层，字符串化操作
#define str(x) str_temp(x)  // 第二层，触发宏参数的展开

str(VALUE)
```

展开过程：

- str(VALUE) 被替换为 str_temp(VALUE)（第一层宏只将 VALUE 传递给第二层）。
- 在展开 str_temp(VALUE) 时：VALUE 首先被展开为 42，然后作为 std_temp 的参数传入。然后 str_temp 对 42 应用字符串化操作符 #，结果是 "42"。通过这种设计，VALUE 的定义得以在字符串化之前完成展开。

如果是单层宏：

```c
#define VALUE 42
#define str(x) #x
```

调用 `str(VALUE)`：

1. `str(VALUE)` 被替换为 `#VALUE`。
2. **`VALUE` 不会展开**，因为 `#` 直接作用于参数 `x`，预处理器认为它是字符串化操作符的目标。
3. 最终结果是 `"VALUE"`。

之后的##的拼接操作亦是如此。

## 宏分析

---

```c
// macro.h
// 总是返回第二个参数
#define CHOOSE2nd(a, b, ...) b

#define MUX_WITH_COMMA(contain_comma, a, b) CHOOSE2nd(contain_comma a, b)
#define MUX_MACRO_PROPERTY(p, macro, a, b) MUX_WITH_COMMA(concat(p, macro), a, b)
// define placeholders for some property
// 占位符
#define __P_DEF_0 X,
#define __P_DEF_1 X,
// define some selection functions based on the properties of BOOLEAN macro
#define MUXDEF(macro, X, Y) MUX_MACRO_PROPERTY(__P_DEF_, macro, X, Y)

//utils.h
// 给str格式化输出，最终还要恢复默认格式，使后续文本不受影响
#define ANSI_FMT(str, fmt) fmt str ANSI_NONE
```

```c
  Log("Trace: %s", MUXDEF(CONFIG_TRACE, ANSI_FMT("ON", ANSI_FG_GREEN), ANSI_FMT("OFF", ANSI_FG_RED)));
```

- MUXDEF
  - macro: CONFIG_TRACE
  - X: ANSI_FMT("ON", ANSI_FG_GREEN)
  - Y: ANSI_FMT("OFF, ANSI_FG_RED)
- MUX_MACRO_PROPERTY
  - p: \__P_DEF_
  - macro: 0/1
  - a: ON(GREEN)
  - b: OFF(RED)
- MUX_WITH_COMMA
  - contain_comma: **P_DEF_0/**P_DEF_1
  - a: ON(GREEN)
  - b: OFF(RED)
- CHOOSE2nd
  - a: X, ON(GREEN)
  - b: OFF(RED)
    ...

只要 CONFIG_TRACE 有值(被定义，无论是 0 还是 1)就输出 ON，否则输出 OFF。ChatGPT 骗了我半天，说 1 会输出 ON，0 会输出 OFF。

## 资料

---

- Mario ROM 下载地址: https://www.romsgames.net/nintendo-rom-mario-bros/
- 指令集架构: https://en.wikipedia.org/wiki/Instruction_set_architecture
- RISC-V: https://github.com/riscv-non-isa/riscv-elf-psabi-doc
