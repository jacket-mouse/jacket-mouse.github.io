---
layout: post
title: 操作系统-PA1
---

## STFSC

---

## nemu/include/macro.h

---

- 宏&预处理运算符

    - https://en.cppreference.com/w/cpp/preprocessor
    - https://en.cppreference.com/w/cpp/preprocessor/replace#Predefined_macros(来自上面的链接)

```c
// macro stringizing
#define str_temp(x) #x
#define str(x) str_temp(x)
```

使用两个宏逐步展开，是为了防止x传入一个宏，如

```c
#define VALUE 42
#define str_temp(x) #x      // 第一层，字符串化操作
#define str(x) str_temp(x)  // 第二层，触发宏参数的展开

str(VALUE)
```

展开过程：

- str(VALUE) 被替换为 str_temp(VALUE)（第一层宏只将 VALUE 传递给第二层）。
- 在展开 str_temp(VALUE) 时：VALUE 首先被展开为 42。然后 str_temp 对 42 应用字符串化操作符 #，结果是 "42"。通过这种设计，VALUE 的定义得以在字符串化之前完成展开。

这个问题的核心在于 **C 预处理器的展开规则**，特别是预处理器如何处理宏参数以及 `#` 和 `##` 操作符的特殊性。以下是深入解释：

---

### **C 预处理器的展开规则**

1. **普通宏展开规则**：
   - 当调用宏时，预处理器会先展开宏参数中包含的宏（递归展开）。
   - 例如：
     ```c
     #define VALUE 42
     #define STR(x) x
     STR(VALUE)  // 会被替换为 42
     ```

2. **字符串化运算符 `#` 的规则**：
   - 当 `#` 运算符作用于一个宏参数时，该参数不会被进一步展开，直接被转化为字符串字面量。
   - 例如：
     ```c
     #define VALUE 42
     #define STR(x) #x
     STR(VALUE)  // 不展开 VALUE，直接得到 "VALUE"
     ```

3. **为什么 `#` 运算符不展开参数？**
   - C 标准规定：`#` 是一个 **操作符**，作用于调用宏时传入的“原始参数”。目的是让程序员可以直接获取参数名本身的字符串形式，而不是其展开后的值。

---

### **两层宏的作用**

两层宏的设计是为了绕过 `#` 运算符对参数展开的限制。通过第一层宏，强制触发参数展开，然后在第二层宏中应用 `#`。

#### 示例代码：
```c
#define VALUE 42
#define str_temp(x) #x
#define str(x) str_temp(x)
```

**展开过程：**

1. 调用 `str(VALUE)`：
   - 替换为 `str_temp(VALUE)`（第一层宏只是传递参数，不包含 `#`，因此 `VALUE` 会被进一步展开为 `42`）。
   - **此时 `VALUE` 已经展开为 `42`**。

2. 调用 `str_temp(42)`：
   - 替换为 `#42`。
   - `#` 运算符将 `42` 转为字符串字面量，结果是 `"42"`。

---

### **为什么单层宏不行？**

#### 单层宏：
```c
#define VALUE 42
#define str(x) #x
```

调用 `str(VALUE)`：
1. `str(VALUE)` 被替换为 `#VALUE`。
2. **`VALUE` 不会展开**，因为 `#` 直接作用于参数 `x`，预处理器认为它是字符串化操作符的目标。
3. 最终结果是 `"VALUE"`。

---

### **总结对比**

| 宏定义                  | 行为                     | 结果         |
|-------------------------|--------------------------|--------------|
| `#define str(x) #x`     | 不展开参数，直接字符串化 | `"VALUE"`    |
| `#define str(x) str_temp(x)` <br> `#define str_temp(x) #x` | 先展开参数，再字符串化 | `"42"` |

---

### **为什么不让 `#` 运算符自动展开参数？**

C 语言的设计初衷是为了提供灵活性：

1. **保留原始参数名**：
   - 有时程序员需要参数本身的字符串形式（如日志记录或调试信息）。

2. **避免意外展开**：
   - 如果 `#` 自动展开参数，可能会导致无法获取参数名，或者产生混淆的结果。

通过这一设计，程序员可以明确控制是否需要展开参数：

- **单层宏**：直接获取参数的字符串形式。
- **两层宏**：先展开参数，再获取其字符串形式。

---

### **参考标准**

这段行为的规范来自于 C 标准的 **6.10.3.2 The `#` operator** 部分：

> A `#` preprocessing token followed by a parameter name within a function-like macro definition causes the replacement text of the macro to be a string literal...

文中明确指出，`#` 作用于**原始参数**，不会触发进一步的展开。

如需进一步解读，可参考 [ISO C 标准 N1570 文档](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf)。

之后的##的拼接操作亦是如此。

## 宏分析

---

```c
// macro.h
// 总是返回第二个参数
#define CHOOSE2nd(a, b, ...) b

#define MUX_WITH_COMMA(contain_comma, a, b) CHOOSE2nd(contain_comma a, b)
#define MUX_MACRO_PROPERTY(p, macro, a, b) MUX_WITH_COMMA(concat(p, macro), a, b)
// define placeholders for some property
// 占位符
#define __P_DEF_0 X,
#define __P_DEF_1 X,
// define some selection functions based on the properties of BOOLEAN macro
#define MUXDEF(macro, X, Y) MUX_MACRO_PROPERTY(__P_DEF_, macro, X, Y)

//utils.h
// 给str格式化输出，最终还要恢复默认格式，使后续文本不受影响
#define ANSI_FMT(str, fmt) fmt str ANSI_NONE
```

```c
  Log("Trace: %s", MUXDEF(CONFIG_TRACE, ANSI_FMT("ON", ANSI_FG_GREEN), ANSI_FMT("OFF", ANSI_FG_RED)));
```

- MUXDEF
    - macro: CONFIG_TRACE
    - X: ANSI_FMT("ON", ANSI_FG_GREEN)
    - Y: ANSI_FMT("OFF, ANSI_FG_RED)
- MUX_MACRO_PROPERTY
    - p: __P_DEF_
    - macro: 0/1
    - a: ON(GREEN)
    - b: OFF(RED)
- MUX_WITH_COMMA
    - contain_comma: __P_DEF_0/__P_DEF_1
    - a: ON(GREEN)
    - b: OFF(RED)
- CHOOSE2nd
    - a: X, ON(GREEN)
    - b: OFF(RED)
    ...

只要CONFIG_TRACE有值(被定义，无论是0还是1)就输出ON，否则输出OFF。ChatGPT骗了我半天，说1会输出ON，0会输出OFF。


## 资料

---

- Mario ROM下载地址: https://www.romsgames.net/nintendo-rom-mario-bros/
- 指令集架构: https://en.wikipedia.org/wiki/Instruction_set_architecture
- RISC-V: https://github.com/riscv-non-isa/riscv-elf-psabi-doc