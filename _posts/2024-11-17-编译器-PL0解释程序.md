---
layout: post
title: 编译器-PL0解释程序
---

这次实验不再进行详细说明，参考资料中都讲的很好，主要针对难点进行阐述，难点懂了，这个实验几乎就完成了 ✅。

## 难点

---

这次实验我一直搞不懂 DL 和 SL 的区别，看了文章也还没搞懂，最终最终问了 AI，让它帮我详细解释解释，才慢慢搞懂。

其实，结合代码来讲是最“形象”🉐。以下的代码来自我的[PL0-Compiler](https://github.com/jacket-mouse/PL0-Compiler)仓库中的测试样例 2。

```PL/0
var x;
procedure B;
var y;
begin
    y := x;
end;

procedure A;
begin
    call B;
end;


begin
    x := 1;
    call A;
end.
```

上述代码的调用关系为：

- 主函数(main)--调用->A
- A--调用->B

SL 静态链和 DL 动态链都记录了当前层的上一层的信息，但这上一层和上一层之间也并不是完全一样。

- SL 静态链：从代码中看，过程 A 和 B 的上一层都是主程序，它们都是在主程序中定义的过程。

- DL 动态链：从调用的角度看，因为主程序调用了 A，所以主程序是 A 的上一层，又因为 A 调用了 B，所以 A 又是 B 的上一层。这就有点不一样了，B 的上一层在代码层面明明是主程序，而在这里却成了 A。

这次我们发现了 DL 和 SL 的不同。

DL (动态链)：

- 记录的是调用关系（运行时动态调用的顺序）。
- 表示调用者，只知道当前子程序是由哪一个子程序调用的。
- 回溯关系是 动态的，依赖实际的调用栈。

SL (静态链)：

- 记录的是词法作用域关系（程序的嵌套结构）。
- 表示定义者，知道当前子程序是在哪一个作用域中定义的。
- 回溯关系是 静态的，依赖编译时的嵌套层次。

## 参考资料

---

- [编译原理课设尝试（一）——PL/0 编译器分析](https://jcf94.com/2016/02/21/2016-02-21-pl0/)
- [PL\0 编译原理实验(南航)四：中间代码的解释器](https://blog.csdn.net/wh_computers/article/details/105746782)
- 完整代码：[https://github.com/jacket-mouse/PL0-Compiler](https://github.com/jacket-mouse/PL0-Compiler)
