---
layout: post
title: 编译器-PL0语法分析
---

本文主要按照笔者逻辑思考的顺序进行语法分析部分的说明。如有不明白的部分请见谅。(完整代码在文章最后，时间紧张可直接跳到文章末尾 ❤️)

在拿到词法分析部分的一个又一个的 Token 时，庞大的语法分析让我无法下手，我不知道如何利用这些 Token，也不知道将 PL/0 语言用上下文无关文法描述出来有什么用，但这并不妨碍我们先将上下文无关文法写出来（看懂）😎

上下文无关文法描述的 PL/0 语言：

- Program → Block .

- Block → [ConstDecl][VarDecl][ProcDecl] Stmt

  程序块的基本结构是：常量定义、变量定义、过程定义、语句

- ConstDecl → const ConstDef {, ConstDef} ;
  常量定义

- ConstDef → ident = number

- VarDecl → var ident {, ident} ;
  变量定义

- ProcDecl → procedure ident ; Block ; {procedure ident ; Block ;}
  过程定义

- Stmt → ident := Exp \| call ident \| begin Stmt {; Stmt} end \| if Cond then Stmt \| while Cond do Stmt \| ε

  赋值语句、调用语句、begin-end 块语句、判断语句、循环语句

- Cond → odd Exp \| Exp RelOp Exp
  条件表达式

- RelOp → = \| <> \| < \| > \| <= \| >=
  关系运算符

- Exp → [+ \| − ] Term {+ Term \| − Term}
  表达式

- Term → Factor {\* Factor \| / Factor}

- Factor → ident \| number \| ( Exp )

- ident：字母开头的字母 / 数字串

- number：无符号整数

从上面的文法中我们可以得到以下的信息：

- 🤔：PL/0 语言有着严格的先后顺序，必须将常量的声明、定义以及变量的声明放在最前面，然后是过程的声明和定义，最后才是语句。
- 😎：过程里可以嵌套过程的定义，过程里也可以调用(call)其他的过程。
- 😴：分号的位置很重要，常量和变量声明和定义的最后有；过程名后有；过程体结束后有；语句(stmt)只有在 begin 中的语句中有。
- 😋：程序最后是以 . 结束的。

有了上述的理解，我们终于知道程序的大概流程了。因为这里我们不用预测分析表，所以对于流程的了解挺重要的。下面将结合流程图展开分析（这里先不着急写代码，一切都理解了写代码其实很快。

程序的入口：

我们进入程序的“大门”，遇到了一个程序体，这里的程序体就像一个黑盒子(函数)，我们一头扎进去，最后又会走出来，然后遇到一个 . ，这样程序就结束了。

![](https://1ees0n.oss-cn-qingdao.aliyuncs.com/Github/PL0-prog.png)

程序体：

下面我们走进黑盒子中，发现又有许多分支 😵，但我们有一个竖向的“主线”，不妨就沿着主线走一遭。第一个“路口”是 const，我们忍住了没进去；第二个“路口”是 var，我们再次忍住了，因为我们是为了走到最后，而不能误入“歧途”。就这样，我们到了第三个 procedure 以及第四个“语句”，终于没有“路”可以走了，我们走到了尽头。

这一路上，我们遇到了很多“分叉口” -- const、var、prodedure 和语句，但我们都不知道里面究竟是什么，它们对我们来说就是一个又一个的黑盒子，没错就是黑盒子，而在之后我们都会定义一个函数来代表黑盒子。这时，你可能感觉到了什么 😳，我们继续往下进行。

![](https://1ees0n.oss-cn-qingdao.aliyuncs.com/Github/PL0-block.png)

语句这个就更容易看出来分了五路，但不同于上面的程序体，语句这五条路，你一次只能选一条！

![](https://1ees0n.oss-cn-qingdao.aliyuncs.com/Github/PL0-stmt.png)

这样基本的程序结构，我们已经分析完了，但毕竟 `talk is cheap. Show me the code` 现在写完整的代码还为时尚早，不如用伪代码（可能）代替。

我们从头开始，进入了一个程序之中，并在其中发现了程序体（黑盒）和一个点号。

```java
prog(){
    block();
    match('.');
}
```

然后是程序体内部，有 const、var 和 procedure 和语句：

```java
block(){
    const();
    var();
    procedure();
    statement();
}
```

最后是语句，有五个分支：

```java
statement(){
    assign();
    call();
    begin();
    if();
    while();
    // 空就不写了
}
```

下面就是对于函数体内部的补充了。

```java
prog(){
  // 直接进入block，没有前兆
  block();
  match('.');
}
```

```java
block(){
  if match("const") const();
  if match("var") var();
  if match("procedure") procedure();
  else statement();
}
```

```java
statement(){
  // 双引号内为终结符
  if match(ident) assign();
  if match("call") call();
  if match("begin") begin();
  if match("if") if();
  if match("while") while();
  // 空就不写了
}
```

程序体第一个分支--const。

```java
const(){
  do
    match(ident);
    match('=');
    match(number);
  while(match(',');)
  match(';');
}
```

第二个分支--var

```java
var(){
  do
    match(ident);
  while(match(',');)
  match(';');
}
```

第三个分支--procedure

```java
procedure(){
  match(ident);
  match(';');
  block();
  match(';');
}
```

statement--assign

```java
assign(){
  match(ident);
  match(':=');
  expression();
}
```

statement--call

```java
call(){
  match(ident);
}
```

statement--begin

```java
begin(){
  do
    statement();
  while(!match("end");)
  match("end");
}
```

statement--if

```java
if(){
  condition();
  match("then");
  statement();
}
```

statement--while

```java
while(){
  condition();
  match("do");
  statement();
}
```

有了对于上述的结构框架，我们终于可以开始该次实验中两个最主要的部分--符号表的建立和中间代码的生成，因此我们分开来说明并实现。

## 符号表的建立

---

根据词法分析，我们能够得到一个又一个的 Token，这时我们就要对这些 Token 进行处理。符号表就是其中一部分。

- 那符号表是什么呢？

  符号表在这次实验中，存储的是常量、变量以及过程(Prodedure)的信息。

  那我们应该如何表示上述的信息呢？在这里我使用了 Java 中的 List 表示一整个表，List 里存放的是 Map，因为 Map 就是键值对，很好的满足我们的要求。正如下图所示，现在我们还不知道里面各字段的含义，但主要结构应该是这样的。

  ![](https://1ees0n.oss-cn-qingdao.aliyuncs.com/Github/PL0-Table.png)

- 我们为什么要建立符号表呢？

  其目的是方便之后的语义分析以及中间代码的生成，所以符号表其实是一个“工具”，有了它我们会变得更加方便，没有的话会遇到很多的麻烦，甚至无法分析。

  举一个例子：之后我们会给变量赋值，如果变量在之前没有声明过，这是要报错的。如果我们不通过符号表记录下来，就无法知道这个变量声明还是没有声明，就无法处理了。

接下来，我们就要开始从零构建一个符号表了。

从之前的图中，我们看到符号表其实主要为三个部分：
常量、变量和过程(procedure)。

### 常量部分

---

常量有三个 Key，分别是：

- name：记录常量的符号名。
- kind：类型，即我们在词法分析中给他的“标签”
- value：常量的值。

这三个 Key 都是比较简单的，因为我们获取到一个 Token，Token 本身就包括 text(name)和 type(kind)属性，所以上面的三个 key 有两个直接给我们了，就还剩下一个 value，而通过分析 PL/0 语言的文法：

- ConstDecl → const ConstDef {, ConstDef} ;
  常量定义
- ConstDef → ident = number

number 必然会跟在 ident 之后，所以第三个 value 的值，也是很简单就能够获取到，这样我们就完成了一个完整的常量 Map 的构造，接下来将其添加到 List 中就可以了。

```

```

```

```
